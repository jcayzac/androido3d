//	ClassGenerator.cpp
//	Copyright (C) 2008 Chris Pruett.		c_pruett@efn.org
//
//	FarClip Engine
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//			http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.


#include "ClassGenerator.h"

#include <algorithm>
#include <cctype> // for tolower
#include <iostream>
#include <string>

#include "ParseElement.h"

using namespace std;

string ClassGenerator::parseTree(const ParseElement* pRoot)
{
	mIndent = 0;
	mErrorCount = 0;
	mOutputString.str("");
	mInlineFunctionString.str("");
	mFactoryFieldConstructionString.str("");

	mClassNameList.clear();
	mRequiresStringMetaField = false;
	mRequiresObjectHandleMetaField = false;
	mRequiresDynamicArrayMetaField = false;

	parseDocument(pRoot);
	string output = mOutputString.str();

	return output;
}

void ClassGenerator::parseNode(const ParseElement* pElement)
{
	if (pElement)
	{
		switch ( pElement->mType )
		{
			case ELEMENT_cruft:
				mOutputString << pElement->mpString;
				break;
			case ELEMENT_metaClass:
				createClass(pElement);
				break;
			case ELEMENT_root:
				parseDocument(pElement);
				break;

			default:
				break;
		}
	}
}

void ClassGenerator::parseDocument(const ParseElement* pElement)
{
	if (pElement)
	{
		mCurrentFileName = pElement->mpString;

		mIndent = -1;
		resetScope();

		parseChildObjects(pElement);

		mOutputString << mInlineFunctionString.str();
		mInlineFunctionString.str("");

		stringstream header;
		header << "// Generated by ClassGen from " << mCurrentFileName << "\n\n";
		header << "#ifndef _HEADER_" << baseName(mCurrentFileName) << "\n";
		header << "#define _HEADER_" << baseName(mCurrentFileName) << "\n\n";
		header << "#include \"MetaBase.h\"\n";
		header << "#include \"MetaField.h\"\n";
		header << "#include \"MetaObject.h\"\n";
		header << "#include \"MetaRegistry.h\"\n";
		if (mRequiresStringMetaField)
		{
			header << "#include \"StringMetaField.h\"\n";
		}

		if (mRequiresObjectHandleMetaField)
		{
			header << "#include \"ObjectHandleMetaField.h\"\n";
		}

		if (mRequiresDynamicArrayMetaField)
		{
			header << "#include \"Array.h\"\n";
			header << "#include \"DynamicArrayMetaField.h\"\n";
		}

		header << "\n";

		header << mOutputString.str();
		header << "\n";
		header << "#endif  //_HEADER_" << baseName(mCurrentFileName);

		mOutputString.str(header.str());
	}
}

void ClassGenerator::parseElement(const ParseElement* pElement)
{
	if (pElement)
	{
		switch (pElement->mType)
		{
			case ELEMENT_comment:
				mOutputString << indentWhitespace() << pElement->mpString << endl;
				break;
			case ELEMENT_field:
				createField(pElement);
				break;
			case ELEMENT_function:
				createFunction(pElement);
				break;
			case ELEMENT_get:
				createAccessor(pElement, true, false);
				break;
			case ELEMENT_set:
				createAccessor(pElement, false, true);
				break;
			case ELEMENT_enum:
				createEnum(pElement);
				break;
		}
	}
}

void ClassGenerator::parseChildObjects(const ParseElement* pElement)
{
	// parse children
	if (pElement)
	{
		mIndent++;
		ParseElement* pChild = const_cast<ParseElement*>(pElement->mpChildren);

		for ( ; pChild != NULL; pChild = const_cast<ParseElement*>(pChild->mpNext))
		{
			parseNode( pChild );
		}
		mIndent--;
	}
}

void ClassGenerator::parseChildAttributes(const ParseElement* pElement)
{
	// parse children
	if (pElement)
	{
		mIndent++;
		ParseElement* pChild = const_cast<ParseElement*>(pElement->mpChildren);

		for ( ; pChild != NULL; pChild = const_cast<ParseElement*>(pChild->mpNext))
		{
			parseElement( pChild );
		}
		mIndent--;
	}
}


void ClassGenerator::createClass(const ParseElement* pElement)
{
	if (pElement)
	{
		const char* pClassName = pElement->mpString;
		string pClassBase = getChildString(pElement, ELEMENT_base);
		if (pClassBase.empty())
		{
			pClassBase = "MetaBase";
		}

		if (pClassName == NULL || (pClassName && strlen(pClassName) == 0))
		{
			error("No metaclass name found!", pElement->mSourceFileLine);
			return;
		}

		const bool isAbstract = (findChild(pElement, ELEMENT_abstract) != NULL);

		const ParseElement* pScope = findChild(pElement, ELEMENT_scope);
		ScopeType scope = pScope ? pScope->mScope : SCOPE_public;

		if (mClassNameList.size() > 0)
		{
			printScope(scope);
		}
		else if (pScope)
		{
			// Scope in class definition isn't meaningful to top-level classes.
			warning("Scope argument isn't relevant to metaclasses that are not nested within other metaclasses.", pScope->mSourceFileLine);
		}

		string currentScopeString = "";
		for (list<char*>::const_iterator x = mClassNameList.begin(); x != mClassNameList.end(); ++x)
		{
			currentScopeString += *x;
			currentScopeString += "::";
		}

		mOutputString << indentWhitespace() << "class " << pClassName << " : public " << pClassBase << "\n";
		mOutputString << indentWhitespace() << "{\n";

		mClassNameList.push_back(const_cast<char*>(pClassName));
		mChildClassNameList.push_back(const_cast<char*>(pClassName));

		resetScope();
		mIndent++;

		// Parse nested classes
		parseChildObjects(pElement);

		// Parse this class' elements
		parseChildAttributes(pElement);

		// generate actual code for inline functions
		createInlineFunctions(pClassName, pClassBase, currentScopeString, isAbstract);

		mMetaFieldArrayString.str("");
		mMetaFieldDefinitionString.str("");
		mFactoryFieldConstructionString.str("");
		mAccessorFunctionString.str("");

		mIndent++;

		printScope(SCOPE_public);

		// finish the class off with function prototypes.
		// generate factory funciton prototype
		mOutputString << indentWhitespace() << "static void initialize(" << pClassName << "* pObject);\n";

		if (!isAbstract)
		{
			mOutputString << indentWhitespace() << "static " << pClassName << "* factory(void* pAddress = 0);\n";
			mOutputString << indentWhitespace() << "static void" << "* factoryRaw(void* pAddress, bool initializeObject);\n";
			mOutputString << indentWhitespace() << "static " << pClassName << "* arrayFactory(int elementCount);\n";
		}

		// generate metadata function prototype
		mOutputString << indentWhitespace() << "static const MetaObject* getClassMetaObject();\n";
		mOutputString << indentWhitespace() << "virtual const MetaObject* getMetaObject() const;\n";
		mOutputString << indentWhitespace() << "static bool registerMetaData();\n";
		mOutputString << indentWhitespace() << "static " << pClassName << "* dynamicCast(MetaBase* pObject);\n\n";

		mClassNameList.remove(const_cast<char*>(pClassName));

		mIndent -= 2;

		// The next object shouldn't be affected by this object's scoping.
		resetScope();

		mOutputString << indentWhitespace() << "};\n\n";
	}

}

void ClassGenerator::createField(const ParseElement* pElement)
{
	if (pElement)
	{
		string pFieldName = pElement->mpString;
		string pFieldType = getChildString(pElement, ELEMENT_type);
		string pFieldValue = getChildString(pElement, ELEMENT_value);
		string pFieldLength = getChildString(pElement, ELEMENT_length);

		bool construct = false;
		bool factoryConstruct = false;
		bool smartPointer = false;
		const bool isDynamicArray = (pFieldLength == "-1");
		const bool isInlineArray = (!pFieldLength.empty() && !isDynamicArray);
		const ParseElement* pFieldConstruct = findChild(pElement, ELEMENT_construct);
		const ParseElement* pRefCount = findChild(pElement, ELEMENT_refCount);

		if (pFieldConstruct)
		{
			construct = true;
			factoryConstruct = (pFieldConstruct->mFlags & FLAG_smart);
		}

		if (pRefCount)
		{
			smartPointer = true;
		}

		if (!pFieldName.empty() && !pFieldType.empty())
		{
			string pActualFieldType = pFieldType;

			// TODO: make this a TMetaField?
			bool isPointer = false;

			string pFieldTypeName = pFieldType;
			string::size_type starPosition = string::npos;
			if (isPointerType(pFieldTypeName, &starPosition))
			{
				isPointer = true;
				pFieldTypeName.erase(starPosition);
			}

			if (smartPointer && !isPointer)
			{
				string message = "Converting ";
				message += pFieldName;
				message += " to a pointer because ref counting was requested.";
				warning(message.c_str(), pElement->mSourceFileLine);
				isPointer = true;
			}

			if (smartPointer)
			{
				pActualFieldType = "ObjectHandle<";
				pActualFieldType += pFieldTypeName;
				pActualFieldType += ">";
			}

			if (isDynamicArray)
			{
				string dynamicArrayType;
				dynamicArrayType = "Array< ";
				dynamicArrayType += pActualFieldType;
				dynamicArrayType += " >";
				pActualFieldType = dynamicArrayType;
			}

			mMetaFieldDefinitionString << "\t" << "static ";

			string metaFieldType = "MetaField";

			if (pFieldType == "char*")
			{
				// special case for strings
				metaFieldType = "StringMetaField";
				mRequiresStringMetaField = true;
			}
			else if (isPointer && smartPointer)
			{
				metaFieldType = "ObjectHandleMetaField";
				mRequiresObjectHandleMetaField = true;
			}

			if (isDynamicArray)
			{
				string dynamicArrayFieldType = "DynamicArrayMetaField<";
				dynamicArrayFieldType += metaFieldType;
				dynamicArrayFieldType += ">";
				metaFieldType = dynamicArrayFieldType;
				mRequiresDynamicArrayMetaField = true;
			}

			mMetaFieldDefinitionString << metaFieldType;

			mMetaFieldDefinitionString << " field_" << pFieldName << "(";

			// insert the actual field pointer into the array
			mMetaFieldArrayString << "\t\t" << "&field_" << pFieldName <<",\n";

			if (isPointer)
			{
				mMetaFieldDefinitionString << "MetaField::TYPE_pointer, \"";
			}
			else
			{
				mMetaFieldDefinitionString << "MetaField::TYPE_value, \"";
			}

			mMetaFieldDefinitionString << pFieldName << "\", \"" << pFieldTypeName << "\", OFFSETOF(" << mClassNameList.back();
			mMetaFieldDefinitionString << ", " << pFieldName << "), sizeof(" << pActualFieldType << ")";

			if (!pFieldLength.empty() && pFieldLength != "1")
			{
				if (isDynamicArray)
				{
					mMetaFieldDefinitionString << ", sizeof(" << pFieldType << ")";
				}
				else
				{
					mMetaFieldDefinitionString << " * " << pFieldLength << ", " << "MetaField::ARRAY_inline, " << pFieldLength << ", sizeof(" << pActualFieldType << ")";
				}
			}

			mMetaFieldDefinitionString << ");\n";


			if (construct || !pFieldValue.empty())
			{
				mFactoryFieldConstructionString << "\t";

				string pCounterVarName = "i_";
				pCounterVarName += pFieldName;

				// handle array initialization
				if (!pFieldLength.empty() && !isDynamicArray)
				{
					mFactoryFieldConstructionString << "for (int " << pCounterVarName << " = 0; ";
					mFactoryFieldConstructionString << pCounterVarName << " < " << pFieldLength << "; ";
					mFactoryFieldConstructionString << pCounterVarName << "++)\n";
					mFactoryFieldConstructionString << "\t" << "{\n";
					mFactoryFieldConstructionString << "\t\t";
				}

				mFactoryFieldConstructionString << "pObject->" << pFieldName;

				if (isInlineArray)
				{
					mFactoryFieldConstructionString << "[" << pCounterVarName << "]";
				}

				if (construct)
				{
					// malloc pointer types
					if (isPointer)
					{
						mFactoryFieldConstructionString << " = ";

						if (factoryConstruct)
						{
							mFactoryFieldConstructionString << pFieldTypeName << "::factory()";
						}
						else
						{
							mFactoryFieldConstructionString << "new " << pFieldTypeName;
						}
					}
					else
					{
						// just initialize non-pointer objects
						mFactoryFieldConstructionString << ".initialize(&" << "pObject->" << pFieldName;
						if (isInlineArray)
						{
							mFactoryFieldConstructionString << "[" << pCounterVarName << "]";
						}
						mFactoryFieldConstructionString << ")";
					}
				}
				else if (!pFieldValue.empty())
				{
					mFactoryFieldConstructionString << " = ";

					// special case for strings
					if (pFieldType == "char*" && pFieldValue != "NULL")
					{
						mFactoryFieldConstructionString << "\"";
					}

					mFactoryFieldConstructionString << pFieldValue;

					if (pFieldType == "char*" && pFieldValue != "NULL")
					{
						mFactoryFieldConstructionString << "\"";
					}
				}
				mFactoryFieldConstructionString << ";\n";

				if (isInlineArray)
				{
					mFactoryFieldConstructionString << "\t" << "}\n";
				}
			}

			// generate the actual field in the class
			const ParseElement* pFieldScope = findChild(pElement, ELEMENT_scope);

			if (pFieldScope)
			{
				printScope(pFieldScope->mScope);
			}
			else
			{
				// default to private for fields
				printScope(SCOPE_private);
			}

			mOutputString << indentWhitespace() <<	pActualFieldType << " " << pFieldName;

			if (isInlineArray && pFieldLength != "1")
			{
				mOutputString <<	"[" << pFieldLength << "]";
			}

			mOutputString << ";\n";
		}

	}
}

void ClassGenerator::createAccessor(const ParseElement* pElement, const bool generateGet, const bool generateSet)
{
	if (pElement)
	{
		const ParseElement* pFieldElement = findChildByString(pElement->mpParent, ELEMENT_field, pElement->mpString);
		if (pFieldElement)
		{
			string pFieldName = pElement->mpString;
			string pFieldType = getChildString(pFieldElement, ELEMENT_type);
			string pFieldLength = getChildString(pFieldElement, ELEMENT_length);
			const bool isDynamicArray = (pFieldLength == "-1");

			bool isPointer = false;

			string pFieldTypeName = pFieldType;


			string::size_type typeStarPosition = string::npos;
			if (isPointerType(pFieldTypeName, &typeStarPosition))
			{
				isPointer = true;
				pFieldTypeName.erase(typeStarPosition);
			}


			string pAccessorName = pFieldName;
			string::size_type nameStarPosition = string::npos;
			if (isPointerType(pAccessorName, &nameStarPosition))
			{
				pAccessorName.erase(nameStarPosition);
			}


			if (pAccessorName[0] == 'm')
			{
				pAccessorName.erase(0, 1);
			}

			// make sure the fist character is uppercase
			transform(pAccessorName.begin(), pAccessorName.begin(), pAccessorName.begin(), (int(*)(int))std::toupper);

			string currentScopeString = "";
			for (list<char*>::const_iterator x = mClassNameList.begin(); x != mClassNameList.end(); ++x)
			{
				currentScopeString += *x;
				currentScopeString += "::";
			}

			const ParseElement* pArgument = findChild(pElement, ELEMENT_argumentType);
			ArgumentType argument = ARGUMENT_value;
			if (pArgument)
			{
				argument = pArgument->mArgument;
			}

			stringstream prototypeBeforeScope;
			stringstream prototypeAfterScope;

			if (generateGet)
			{
				bool makeAccessorConst = false;
				bool returnValueConst = false;
				if (pArgument)
				{
					returnValueConst = (pArgument->mFlags & FLAG_const);
				}

				// if we're returning something const, or just returning by value, make the
				// accessor function itself const.
				if (returnValueConst || argument == ARGUMENT_value)
				{
					makeAccessorConst = true;
				}

				if (returnValueConst)
				{
					prototypeBeforeScope << "const ";
				}

				const ParseElement* pRefCount = findChild(pFieldElement, ELEMENT_refCount);

				if (isDynamicArray)
				{
					prototypeBeforeScope << "Array<";
					if (pRefCount)
					{
						prototypeBeforeScope << " ObjectHandle<";
					}
				}

				// If the field in question is of a type defined within this class, we need to know that so we can
				// generate the correct scope for the return type.
				const ParseElement* pInternalClass = findChildByString(pElement->mpParent, ELEMENT_metaClass, pFieldTypeName);
				const ParseElement* pInternalEnum = findChildByString(pElement->mpParent, ELEMENT_enum, pFieldTypeName);
				const ParseElement* pInternalDefinition = pInternalClass != NULL ? pInternalClass : pInternalEnum;

				if (pInternalDefinition)
				{
					prototypeBeforeScope << currentScopeString;
				}

				prototypeBeforeScope << pFieldTypeName;

				if (isDynamicArray)
				{
					if (pRefCount)
					{
						prototypeBeforeScope << "> ";
					}
					else if (isPointer)
					{
						prototypeBeforeScope << "*";
					}
					prototypeBeforeScope << ">";
				}

				// isPointer refers to the field type.  When the field is a dynamic array, that means that the field
				// is a non-pointer to an array object that is full of pointers. So in that case, only output a * on the isPointer flag
				// if the type isn't a dynamic array.
				if (argument == ARGUMENT_reference)
				{
					prototypeBeforeScope << "&";
				}
				else if ((isPointer && !isDynamicArray) || argument == ARGUMENT_pointer)
				{
					prototypeBeforeScope << "*";
				}

				prototypeAfterScope << "get" << pAccessorName << "()";

				if (makeAccessorConst)
				{
					prototypeAfterScope << " const";
				}

				mAccessorFunctionString << "inline " << prototypeBeforeScope.str();
				mAccessorFunctionString << " " << currentScopeString << prototypeAfterScope.str() << endl;
				mAccessorFunctionString << "{\n";
				mAccessorFunctionString << "\t" << "return ";
				if (argument == ARGUMENT_pointer && (!isPointer || (isPointer && isDynamicArray)))
				{
					// Return the address of the field rather than the field itself.
					mAccessorFunctionString << "&";
				}
				mAccessorFunctionString << pFieldName << ";\n";
				mAccessorFunctionString << "}\n";
			}

			if (generateSet)
			{
				prototypeBeforeScope << "void";
				prototypeAfterScope << "set" << pAccessorName << "(";

				if (pArgument && pArgument->mFlags & FLAG_const)
				{
					prototypeAfterScope << "const ";
				}

				if (isDynamicArray)
				{
					prototypeAfterScope << "Array<";
				}

				prototypeAfterScope << pFieldTypeName;

				if (isDynamicArray)
				{
					if (isPointer)
					{
						prototypeAfterScope << "*";
					}
					prototypeAfterScope << ">";
				}

				// See comment above about dynamic arrays and isPointer.
				if (argument == ARGUMENT_reference)
				{
					prototypeAfterScope << "&";
				}
				else if ((isPointer && !isDynamicArray) || argument == ARGUMENT_pointer)
				{
					prototypeAfterScope << "*";
				}

				prototypeAfterScope << " value)";

				mAccessorFunctionString << "inline " << prototypeBeforeScope.str() << " " << currentScopeString;
				mAccessorFunctionString	<< prototypeAfterScope.str() << endl;
				mAccessorFunctionString << "{\n";
				mAccessorFunctionString << "\t" << pFieldName << " = ";
				if (argument == ARGUMENT_pointer && (!isPointer || (isPointer && isDynamicArray)))
				{
					// Dereference the argument before assignment.
					mAccessorFunctionString << "*";
				}

				mAccessorFunctionString << "value;\n";

				mAccessorFunctionString << "}\n";
			}

			const ParseElement* pScope = findChild(pElement, ELEMENT_scope);
			ScopeType scope = pScope ? pScope->mScope : SCOPE_public;

			// generate function prototype
			printScope(scope);

			mOutputString << indentWhitespace() << prototypeBeforeScope.str() << " " << prototypeAfterScope.str() << ";" << endl;
		}
		else
		{
			string message = "Cannot generate ";
			if (generateGet)
			{
				message += "accessor";
			}
			else
			{
				message += "mutator";
			}

			message += " for field '";
			message += pElement->mpString;
			message += "' because no such field exists.";
			error(message.c_str(), pElement->mSourceFileLine);
		}
	}
}

void ClassGenerator::createFunction(const ParseElement* pElement)
{
	if (pElement)
	{
		const char* pFunction = pElement->mpString;
		const ParseElement* pScope = findChild(pElement, ELEMENT_scope);
		ScopeType scope = pScope ? pScope->mScope : SCOPE_public;

		if (pFunction)
		{
			printScope(scope);

			mOutputString << indentWhitespace() << pFunction << ";\n";
		}

	}
}

void ClassGenerator::createEnum(const ParseElement* pElement)
{
	if (pElement)
	{
		const char* pEnumName = pElement->mpString;
		const ParseElement* pScope = findChild(pElement, ELEMENT_scope);
		ScopeType scope = pScope ? pScope->mScope : SCOPE_public;

		printScope(scope);

		mOutputString << indentWhitespace() << "enum ";

		if (pEnumName)
		{
			mOutputString << pEnumName;
		}

		mOutputString << "\n";
		mOutputString << indentWhitespace() << "{\n";

		// for enums, we need to parse the children manually
		ParseElement* pChild = const_cast<ParseElement*>(pElement->mpChildren);

		for ( ; pChild != NULL; pChild = const_cast<ParseElement*>(pChild->mpNext))
		{
			if (pChild->mType == ELEMENT_value)
			{
				const char* pEntryName = pChild->mpString;
				const char* pEntryValue = pChild->mpValue;

				if (pEntryName)
				{
					mIndent++;
					mOutputString << indentWhitespace() << pEntryName;

					if (pEntryValue)
					{
						mOutputString << " = " << pEntryValue;
					}

					if (pChild->mpNext!= NULL && pChild->mpNext->mType == ELEMENT_value)
					{
						mOutputString << ",";
					}

					mOutputString << "\n";

					mIndent--;

				}
			}
		}

		mOutputString << indentWhitespace() << "};\n\n";

	}
}


void	ClassGenerator::createInlineFunctions(const std::string& pClassName,
		const std::string& pClassBase,
		const std::string& pScopeString,
		const bool isAbstract)
{

	// generate init function
	mInlineFunctionString << "\ninline void " << pScopeString << pClassName << "::initialize(" << pClassName << "* pObject)\n";
	mInlineFunctionString << "{\n";
	if (!pClassBase.empty() && pClassBase != "MetaBase")
	{
		mInlineFunctionString << "\t" << pClassBase << "::initialize(pObject);\n";
	}
	mInlineFunctionString << mFactoryFieldConstructionString.str();
	mInlineFunctionString << "}\n";


	// if not an abstract class, generate the factory functions
	// first: factoryRaw()
	if (isAbstract == false)
	{
		mInlineFunctionString << "\ninline void* " << pScopeString << pClassName << "::factoryRaw(void* pAddress, bool initializeObject)\n";
		mInlineFunctionString << "{\n";
		mInlineFunctionString << "\t" << pClassName << "* pObject;\n";
		mInlineFunctionString << "\t" << "if (pAddress == 0)\n";
		mInlineFunctionString << "\t" << "{\n";
		mInlineFunctionString << "\t\t" << "pObject = new " << pClassName << ";\n";
		mInlineFunctionString << "\t" << "}\n";
		mInlineFunctionString << "\t" << "else // in-place new\n";
		mInlineFunctionString << "\t" << "{\n";
		mInlineFunctionString << "\t\t" << "// activate the createInPlace flag so constructors can know not to clear data.\n";
		mInlineFunctionString << "\t\t" << "const bool cachedCreateSetting = Serializable::getCreateInPlace();\n";
		mInlineFunctionString << "\t\t" << "Serializable::setCreateInPlace(true);\n";
		mInlineFunctionString << "\t\t" << "pObject = new (pAddress) " << pClassName << ";\n";
		mInlineFunctionString << "\t\t" << "Serializable::setCreateInPlace(cachedCreateSetting);\n";
		mInlineFunctionString << "\t" << "}\n\n";
		mInlineFunctionString << "\t" << "if (initializeObject && pObject != NULL)";
		mInlineFunctionString << "\t" << "{\n";
		mInlineFunctionString << "\t\t" << "initialize(pObject);";
		mInlineFunctionString << "\t" << "}\n\n";
		mInlineFunctionString << "\t" << "return pObject;\n";
		mInlineFunctionString << "}\n\n\n";

		// second: factory()
		mInlineFunctionString << "inline " << pScopeString << pClassName << "* " << pScopeString << pClassName << "::factory(void* pAddress)\n";
		mInlineFunctionString << "{\n";
		mInlineFunctionString << "\t" << pClassName << "* pObject = static_cast<" << pClassName << "*>(factoryRaw(pAddress, true));\n";
		mInlineFunctionString << "\t" << "if (pObject != NULL)\n";
		mInlineFunctionString << "\t" << "{\n";
		mInlineFunctionString << "\t\t" << "pObject->registerMetaData();\n";
		mInlineFunctionString << "\t" << "}\n";
		mInlineFunctionString << "\t" << "return pObject;\n";
		mInlineFunctionString << "}\n\n";

		// third: arrayFactory()
		mInlineFunctionString << "inline " << pScopeString << pClassName << "* " << pScopeString << pClassName << "::arrayFactory(int elementCount)\n";
		mInlineFunctionString << "{\n";
		mInlineFunctionString << "\t" << pClassName << "* pObjectArray = new " << pClassName << "[elementCount];\n";
		mInlineFunctionString << "\t" << "if (pObjectArray != NULL)\n";
		mInlineFunctionString << "\t" << "{\n";
		mInlineFunctionString << "\t\t" << "for (int x_ = 0; x_ < elementCount; x_++)\n";
		mInlineFunctionString << "\t\t" << "{\n";
		mInlineFunctionString << "\t\t\t" << "initialize(&pObjectArray[x_]);\n";
		mInlineFunctionString << "\t\t" << "}\n";
		mInlineFunctionString << "\t\t" << "pObjectArray[0].registerMetaData();\n";
		mInlineFunctionString << "\t" << "}\n";
		mInlineFunctionString << "\t" << "return pObjectArray;\n";
		mInlineFunctionString << "}\n\n";
	}

	// generate metadata function
	mInlineFunctionString << "\ninline const MetaObject* " << pScopeString << pClassName << "::getClassMetaObject()\n";
	mInlineFunctionString << "{\n";

	if (mMetaFieldArrayString.str().length() > 0)
	{
		mInlineFunctionString << mMetaFieldDefinitionString.str() << "\n";
		mInlineFunctionString << "\t" << "static const MetaField* fields[] = \n";
		mInlineFunctionString << "\t" << "{\n";
		mInlineFunctionString << mMetaFieldArrayString.str();
		mInlineFunctionString << "\t" << "}; \n";
	}

	// generate the meta object
	mInlineFunctionString << "\tstatic MetaObject meta(\"" << pClassName << "\", MetaObject::generateTypeIDFromString(\"" << pClassName << "\"), ";
	if (pClassBase != "MetaBase")
	{
		mInlineFunctionString << "MetaObject::generateTypeIDFromString(\"" << pClassBase << "\"), ";
	}
	else
	{
		mInlineFunctionString << "0, ";
	}

	mInlineFunctionString << "sizeof(" << pClassName << "), ";


	if (mMetaFieldArrayString.str().length() > 0)
	{
		mInlineFunctionString << "static_cast<int>(sizeof(fields) / sizeof(MetaField*)), fields, ";
	}
	else
	{
		mInlineFunctionString << "0, NULL, ";
	}

	if (pClassBase != "MetaBase")
	{
		mInlineFunctionString << pClassBase << "::getClassMetaObject(), ";
	}
	else
	{
		mInlineFunctionString << "NULL, ";
	}

	if (isAbstract == false)
	{
		mInlineFunctionString << "&" << pClassName << "::factoryRaw);\n";
	}
	else
	{
		mInlineFunctionString << "NULL);\n";
	}

	mInlineFunctionString << "\t" << "return &meta;\n";
	mInlineFunctionString << "}\n\n\n";

	// generate meta object accessor
	mInlineFunctionString << "inline const MetaObject* " << pScopeString << pClassName << "::getMetaObject() const\n";
	mInlineFunctionString << "{\n";
	mInlineFunctionString << "\t" << "return getClassMetaObject();\n";
	mInlineFunctionString << "}\n\n";

	// generate meta registration function
	mInlineFunctionString << "inline bool " << pScopeString << pClassName << "::registerMetaData()\n";
	mInlineFunctionString << "{\n";

	// call child object's metas
	for (list<char*>::reverse_iterator x = mChildClassNameList.rbegin();
		x != mChildClassNameList.rend() && strcmp(*x, pClassName.c_str()) != 0; ++x)
	{
		mInlineFunctionString << "\t" << *x << "::registerMetaData();\n";
	}
	mChildClassNameList.clear();

	mInlineFunctionString << "\t" << "MetaRegistry::getMetaRegistry()->addMetaObject(getClassMetaObject());\n";
	mInlineFunctionString << "\t" << "return true;\n";
	mInlineFunctionString << "}\n\n";

	// generate dynamic cast function
	mInlineFunctionString << "inline " << pScopeString << pClassName << "* " << pScopeString << pClassName << "::dynamicCast(MetaBase* pObject)\n";
	mInlineFunctionString << "{\n";
	mInlineFunctionString << "\t" << pClassName << "* " << "result = NULL;\n";
	mInlineFunctionString << "\t" << "if (pObject && getClassMetaObject()->isOfType(pObject->getMetaObject()))\n";
	mInlineFunctionString << "\t" << "{\n";
	mInlineFunctionString << "\t\t" << "result = static_cast<" << pClassName << "*>(pObject);\n";
	mInlineFunctionString << "\t" << "}\n";
	mInlineFunctionString << "\t" << "return result;\n";
	mInlineFunctionString << "}\n\n";

	// generate static registration
	mInlineFunctionString << "#if defined(METADATA_STATIC_REGISTRATION)\n";
	mInlineFunctionString << "\t" << "static bool s_staticRegistration_" << pClassName << " = " << pScopeString << pClassName << "::registerMetaData();\n";
	mInlineFunctionString << "#endif // METADATA_STATIC_REGISTRATION\n\n";


	// add user-requested accessors
	mInlineFunctionString << mAccessorFunctionString.str();
}

string ClassGenerator::lowerCase(const string& input) const
{
	string output = input;
	transform(output.begin(), output.end(), output.begin(), (int(*)(int))std::tolower);
	return output;
}

// strips paths and suffixes off of file names
string ClassGenerator::baseName(const string& input) const
{
	string output = input;

	const string::size_type periodIndex = output.find_first_of('.');
	if (periodIndex != string::npos)
	{
		output.resize(static_cast<int>(periodIndex));
	}

	// find the last slash, supporing forward or backward slashes
	string::size_type slashIndex = output.find_last_of('/');
	if (slashIndex == string::npos)
	{
		slashIndex = output.find_last_of('\\');
	}

	if (slashIndex != string::npos)
	{
		output = output.substr(static_cast<int>(slashIndex) + 1);
	}


	return output;
}

string ClassGenerator::indentWhitespace(int indentOffset) const
{
	string output = "";
	for (int x = 0; x < mIndent + indentOffset; x++)
	{
		output += "\t";
	}

	return output;
}

const ParseElement* ClassGenerator::findChild(const ParseElement* pElement, const ElementType type) const
{
	ParseElement* pFound = NULL;
	if (pElement)
	{
		ParseElement* pChild = pElement->mpChildren;
		while (pChild)
		{
			if (pChild->mType == type)
			{
				pFound = pChild;
				break;
			}

			pChild = pChild->mpNext;
		}
	}
	return pFound;
}

const ParseElement* ClassGenerator::findChildByString(const ParseElement* pElement, const ElementType type, const string& name) const
{
	ParseElement* pFound = NULL;
	if (pElement)
	{
		ParseElement* pChild = pElement->mpChildren;
		while (pChild)
		{
			if (pChild->mType == type && pChild->mpString != NULL && name == pChild->mpString)
			{
				pFound = pChild;
				break;
			}

			pChild = pChild->mpNext;
		}
	}
	return pFound;
}
string ClassGenerator::getChildString(const ParseElement* pElement, const ElementType type) const
{
	const ParseElement* pChild = findChild(pElement, type);
	string result = "";
	if (pChild && pChild->mpString)
	{
		result = pChild->mpString;
	}
	return result;
}

bool ClassGenerator::isPointerType(const string& typeName, string::size_type* position)
{
	bool isPointer = false;
	// Template<type*> // not a pointer
	// Template<type*>* // pointer
	// Type* const // pointer
	// Type const * const // pointer
	string::size_type typeStarPosition = typeName.rfind('*');
	if (typeStarPosition != string::npos)
	{
		if (typeName.find('>', typeStarPosition) == string::npos)
		{
			*position = typeStarPosition;
			isPointer = true;
		}
	}

	return isPointer;
}

void ClassGenerator::printScope(ScopeType scope)
{
	if (mCurrentScope != scope)
	{
		switch (scope)
		{
			case SCOPE_public:
				mOutputString << indentWhitespace(-1) << "public:\n";
				break;
			case SCOPE_protected:
				mOutputString << indentWhitespace(-1) << "protected:\n";
				break;
			case SCOPE_private:
				mOutputString << indentWhitespace(-1) << "private:\n";
				break;
			default:
				error("Invalid scope type detected!.	Valid scopes are 'public', 'protected', and 'private'.", 0);
				break;
		}
	}
	mCurrentScope = scope;
}

void ClassGenerator::resetScope()
{
	mCurrentScope = SCOPE_invalid;
}

void ClassGenerator::error(const char* message, int line)
{
	cerr << mCurrentFileName << ":" << line << ": error: " << message << endl;
	mErrorCount++;
}

void ClassGenerator::warning(const char* message, int line)
{
	cerr << mCurrentFileName << ":" << line << ": warning: " << message << endl;
}

